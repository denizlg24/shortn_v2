# üîí Security & Reliability Audit for Shortn

## üö® CRITICAL ISSUES

### 2. **Missing Input Sanitization for MongoDB Queries**

**Files:**

- bioPageActions.ts (lines 15, 35, 65, 150, 180, 215)
- linkActions.ts (multiple locations)
- qrCodeActions.ts (multiple locations)

**Likelihood:** üî¥ **HIGH**  
**Impact:** NoSQL Injection, data exposure

**Example Vulnerability:**

```typescript
// app/actions/bioPageActions.ts:15
const bioPage = await BioPage.findOne({ slug }); // ‚ùå No sanitization
```

**Fix:**

```typescript
import validator from "validator";
import { Types } from "mongoose";

// Sanitize string inputs
const sanitizedSlug = validator.escape(slug.trim());

// Validate ObjectIds
if (!Types.ObjectId.isValid(id)) {
  return { success: false, message: "invalid-id" };
}

// Use query builders with type safety
const bioPage = await BioPage.findOne({
  slug: { $eq: sanitizedSlug },
});
```

---

### 3. **Authentication Bypass via Direct API Calls**

**Files:**

- route.ts
- route.ts
- route.ts

**Likelihood:** üî¥ **HIGH**  
**Impact:** Unauthorized data access

**Issue:** No authentication checks on sensitive endpoints

**Fix:**

```typescript
// app/api/clicks/[urlCode]/route.ts
import { getServerSession } from "next-auth";
import { authOptions } from "../../auth/[...nextAuth]/route";

export async function GET(
  req: Request,
  { params }: { params: { urlCode: string } },
) {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Verify ownership
  const link = await UrlV3.findOne({ urlCode: params.urlCode });
  if (link.userId.toString() !== session.user.id) {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  // ... rest of logic
}
```

---

### 4. **Stripe Webhook Signature Not Verified**

**Files:** route.ts (lines 10-50)

**Likelihood:** üî¥ **HIGH**  
**Impact:** Payment fraud, unauthorized upgrades

**Current Code:**

```typescript
// ‚ùå CRITICAL: No signature verification
const event = await req.json();
```

**Fix:**

```typescript
import Stripe from "stripe";

export async function POST(req: Request) {
  const body = await req.text();
  const signature = req.headers.get("stripe-signature");

  if (!signature) {
    return NextResponse.json({ error: "No signature" }, { status: 400 });
  }

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!,
    );
  } catch (err) {
    console.error("Webhook signature verification failed:", err);
    return NextResponse.json({ error: "Invalid signature" }, { status: 400 });
  }

  // Process event...
}
```

---

## ‚ö†Ô∏è HIGH SEVERITY ISSUES

### 5. **Race Conditions in Link Updates**

**Files:** linkActions.ts (updateLink, deleteLink functions)

**Likelihood:** üü† **MEDIUM**  
**Impact:** Data inconsistency, lost updates

**Issue:** No transaction support for related updates

**Fix:**

```typescript
import mongoose from "mongoose";

export async function deleteLink(urlCode: string) {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const link = await UrlV3.findOne({ urlCode }).session(session);

    // Delete related data
    await Click.deleteMany({ urlCode }).session(session);
    await QRCodeV2.deleteMany({ dynamicLinkId: link._id }).session(session);
    await BioPage.updateMany(
      { "links.link": link._id },
      { $pull: { links: { link: link._id } } },
    ).session(session);

    await link.deleteOne({ session });

    await session.commitTransaction();
    return { success: true };
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

---

### 6. **Email Token Predictability**

**Files:** Token.ts, env.ts (EMAIL_TOKEN_SUFFIX)

**Likelihood:** üü† **MEDIUM**  
**Impact:** Account takeover

**Issue:** Token generation uses timestamp + suffix (predictable)

**Fix:**

```typescript
import crypto from "crypto";

// Generate cryptographically secure tokens
const token = crypto.randomBytes(32).toString("hex");

// Hash tokens before storage
const hashedToken = crypto.createHash("sha256").update(token).digest("hex");

// Store hashedToken in DB, send plain token via email
await Token.create({
  userId,
  token: hashedToken,
  expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
});
```

---

### 7. **Missing Rate Limiting**

**Files:** All API routes (`app/api/**`)

**Likelihood:** üü† **MEDIUM-HIGH**  
**Impact:** DDoS, brute force attacks, resource exhaustion

**Fix:**

```typescript
// middleware.ts
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, "10 s"),
});

export async function middleware(request: Request) {
  const ip = request.headers.get("x-forwarded-for") ?? "anonymous";
  const { success, limit, reset, remaining } = await ratelimit.limit(ip);

  if (!success) {
    return new Response("Too Many Requests", {
      status: 429,
      headers: {
        "X-RateLimit-Limit": limit.toString(),
        "X-RateLimit-Remaining": remaining.toString(),
        "X-RateLimit-Reset": reset.toString(),
      },
    });
  }

  return NextResponse.next();
}
```

---

### 8. **XSS Vulnerability in Bio Page Display**

**Files:** bio-page-display.tsx (lines 200+)

**Likelihood:** üü† **MEDIUM**  
**Impact:** Account compromise, data theft

**Issue:** User-controlled content rendered without sanitization

**Current Code:**

```tsx
<h1>{bio.title}</h1> {/* ‚ùå No sanitization */}
<p>{bio.description}</p> {/* ‚ùå No sanitization */}
```

**Fix:**

```typescript
import DOMPurify from 'isomorphic-dompurify';

// Sanitize all user input
const sanitizedTitle = DOMPurify.sanitize(bio.title);
const sanitizedDescription = DOMPurify.sanitize(bio.description);

<h1 dangerouslySetInnerHTML={{ __html: sanitizedTitle }} />
<p dangerouslySetInnerHTML={{ __html: sanitizedDescription }} />
```

---

### 9. **Insecure Password Reset Flow**

**Files:**

- authenticate.ts (resetPassword function)
- ResetToken.ts

**Likelihood:** üü† **MEDIUM**  
**Impact:** Account takeover

**Issues:**

- No rate limiting on reset requests
- Token not invalidated after use
- No notification to user when password changes

**Fix:**

```typescript
export async function resetPassword(token: string, password: string) {
  // Rate limit check
  const recentResets = await ResetToken.countDocuments({
    createdAt: { $gte: new Date(Date.now() - 60 * 60 * 1000) },
  });

  if (recentResets > 5) {
    return { success: false, message: "rate-limited" };
  }

  const resetToken = await ResetToken.findOne({
    token,
    used: false,
    expiresAt: { $gt: new Date() },
  });

  if (!resetToken) {
    return { success: false, message: "invalid-token" };
  }

  // Update password
  const user = await User.findById(resetToken.userId);
  user.password = await bcrypt.hash(password, 10);
  await user.save();

  // Mark token as used
  resetToken.used = true;
  await resetToken.save();

  // Send notification email
  await sendEmail({
    to: user.email,
    subject: "Password Changed",
    html: "Your password was recently changed...",
  });

  // Invalidate all sessions
  await LoginActivity.deleteMany({ userId: user._id });

  return { success: true };
}
```

---

### 10. **File Upload Vulnerabilities**

**Files:** uploadImage.ts

**Likelihood:** üü† **MEDIUM**  
**Impact:** Malware upload, server compromise, storage abuse

**Issues:**

- No file size validation before upload
- MIME type validation only (can be spoofed)
- No virus scanning
- No rate limiting

**Fix:**

```typescript
import sharp from "sharp";
import crypto from "crypto";

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ALLOWED_TYPES = ["image/jpeg", "image/png", "image/webp"];

export async function uploadImage(formData: FormData) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return { success: false, message: "unauthorized" };
  }

  const file = formData.get("file") as File;

  // Validate size before reading
  if (file.size > MAX_FILE_SIZE) {
    return { success: false, message: "file-too-large" };
  }

  // Validate MIME type
  if (!ALLOWED_TYPES.includes(file.type)) {
    return { success: false, message: "invalid-file-type" };
  }

  const buffer = Buffer.from(await file.arrayBuffer());

  // Re-encode image to strip metadata and validate format
  try {
    const processedImage = await sharp(buffer)
      .resize(2000, 2000, { fit: "inside", withoutEnlargement: true })
      .jpeg({ quality: 85 })
      .toBuffer();

    // Generate secure filename
    const filename = `${crypto.randomBytes(16).toString("hex")}.jpg`;

    // Upload to Pinata with user attribution
    const result = await pinata.upload
      .file(new File([processedImage], filename, { type: "image/jpeg" }))
      .addMetadata({
        userId: session.user.id,
        uploadedAt: new Date().toISOString(),
      });

    return { success: true, url: result.url };
  } catch (error) {
    console.error("Image processing failed:", error);
    return { success: false, message: "invalid-image" };
  }
}
```

---

## üü° MEDIUM SEVERITY ISSUES

### 11. **Unvalidated Redirects**

**Files:** route.ts

**Likelihood:** üü° **LOW-MEDIUM**  
**Impact:** Phishing, malware distribution

**Issue:** No validation of redirect URLs

**Fix:**

```typescript
import { URL } from "url";

const BLOCKED_PROTOCOLS = ["javascript:", "data:", "vbscript:"];
const BLOCKED_DOMAINS = ["malicious-site.com"]; // Maintain blocklist

function isValidRedirectUrl(url: string): boolean {
  try {
    const parsed = new URL(url);

    // Block dangerous protocols
    if (BLOCKED_PROTOCOLS.includes(parsed.protocol.toLowerCase())) {
      return false;
    }

    // Block known malicious domains
    if (BLOCKED_DOMAINS.includes(parsed.hostname.toLowerCase())) {
      return false;
    }

    return true;
  } catch {
    return false;
  }
}

export async function GET(
  req: Request,
  { params }: { params: { slug: string } },
) {
  const url = await UrlV3.findOne({ urlCode: params.slug });

  if (!url || !isValidRedirectUrl(url.longUrl)) {
    return NextResponse.json({ error: "Invalid URL" }, { status: 400 });
  }

  // Track click...
  return NextResponse.redirect(url.longUrl);
}
```

---

### 12. **MongoDB Connection Leaks**

**Files:** mongodb.ts, all server actions

**Likelihood:** üü° **MEDIUM**  
**Impact:** Performance degradation, connection exhaustion

**Issue:** No connection pooling configuration

**Fix:**

```typescript
// lib/mongodb.ts
import mongoose from "mongoose";

const MONGODB_URI = process.env.MONGODB_KEY;

if (!MONGODB_URI) {
  throw new Error("Please define MONGODB_KEY environment variable");
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

export async function connectDB() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
      maxPoolSize: 10,
      minPoolSize: 2,
      socketTimeoutMS: 45000,
      serverSelectionTimeoutMS: 5000,
      family: 4,
    };

    cached.promise = mongoose
      .connect(MONGODB_URI, opts)
      .then((mongoose) => mongoose);
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}
```

---

### 13. **Insufficient Error Handling**

**Files:** All server actions

**Likelihood:** üü° **MEDIUM**  
**Impact:** Information disclosure, poor UX

**Issue:** Generic error messages, stack traces exposed

**Fix:**

```typescript
// Create error handler utility
// lib/error-handler.ts
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public isOperational: boolean = true,
  ) {
    super(message);
  }
}

export function handleError(error: unknown) {
  if (error instanceof AppError) {
    return {
      success: false,
      message: error.message,
      statusCode: error.statusCode,
    };
  }

  // Log unexpected errors
  console.error("Unexpected error:", error);

  // Don't expose internal errors to client
  return {
    success: false,
    message: "An unexpected error occurred",
    statusCode: 500,
  };
}

// Usage in actions:
try {
  // ... action logic
} catch (error) {
  if (error.code === 11000) {
    throw new AppError("Slug already exists", 409);
  }
  throw error;
}
```

---

### 14. **Session Fixation Vulnerability**

**Files:** route.ts

**Likelihood:** üü° **LOW-MEDIUM**  
**Impact:** Session hijacking

**Issue:** Session not regenerated after login

**Fix:**

```typescript
// app/api/auth/[...nextAuth]/route.ts
export const authOptions: NextAuthOptions = {
  // ...existing config
  callbacks: {
    async signIn({ user, account }) {
      // Regenerate session on login
      await LoginActivity.create({
        userId: user.id,
        provider: account?.provider,
        ip: req.headers.get("x-forwarded-for"),
        userAgent: req.headers.get("user-agent"),
        timestamp: new Date(),
      });
      return true;
    },
    async session({ session, token }) {
      // Add session validation
      const isValid = await validateSession(token.sessionId);
      if (!isValid) {
        throw new Error("Invalid session");
      }
      return session;
    },
  },
  events: {
    async signOut({ token }) {
      // Clean up on signout
      await LoginActivity.deleteOne({ sessionId: token.sessionId });
    },
  },
};
```

---

### 15. **CORS Misconfiguration**

**Files:** All API routes (no CORS headers set)

**Likelihood:** üü° **LOW**  
**Impact:** Unauthorized API access from malicious sites

**Fix:**

```typescript
// middleware.ts
export function middleware(request: NextRequest) {
  const response = NextResponse.next();

  // Set CORS headers
  const origin = request.headers.get("origin");
  const allowedOrigins = ["https://shortn.at", "https://www.shortn.at"];

  if (origin && allowedOrigins.includes(origin)) {
    response.headers.set("Access-Control-Allow-Origin", origin);
    response.headers.set(
      "Access-Control-Allow-Methods",
      "GET, POST, PUT, DELETE",
    );
    response.headers.set(
      "Access-Control-Allow-Headers",
      "Content-Type, Authorization",
    );
    response.headers.set("Access-Control-Allow-Credentials", "true");
  }

  // Security headers
  response.headers.set("X-Frame-Options", "DENY");
  response.headers.set("X-Content-Type-Options", "nosniff");
  response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin");
  response.headers.set(
    "Content-Security-Policy",
    "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';",
  );

  return response;
}

export const config = {
  matcher: "/api/:path*",
};
```

---

### 16. **Weak Password Policy**

**Files:** page.tsx, User.ts

**Likelihood:** üü° **MEDIUM**  
**Impact:** Weak passwords, account compromise

**Issue:** No password strength requirements

**Fix:**

```typescript
// lib/password-validator.ts
import zxcvbn from "zxcvbn";

export function validatePassword(password: string, userData: string[] = []) {
  const minLength = 12;
  const result = zxcvbn(password, userData);

  if (password.length < minLength) {
    return {
      valid: false,
      message: `Password must be at least ${minLength} characters`,
    };
  }

  if (result.score < 3) {
    return {
      valid: false,
      message: `Password is too weak. ${result.feedback.warning || result.feedback.suggestions[0]}`,
    };
  }

  // Check for common patterns
  if (/^(.)\1+$/.test(password)) {
    return {
      valid: false,
      message: "Password cannot be all the same character",
    };
  }

  return { valid: true };
}

// Use in registration:
const passwordValidation = validatePassword(password, [email, username]);
if (!passwordValidation.valid) {
  form.setError("password", { message: passwordValidation.message });
  return;
}
```

---

### 17. **Missing CSRF Protection**

**Files:** All forms (no CSRF tokens)

**Likelihood:** üü° **MEDIUM**  
**Impact:** Unauthorized actions via social engineering

**Fix:**

```typescript
// Use Next.js built-in CSRF protection
// app/api/csrf/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { generateCsrfToken } from "@/lib/csrf";

export async function GET() {
  const session = await getServerSession();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const token = generateCsrfToken(session.user.id);
  return NextResponse.json({ csrfToken: token });
}

// lib/csrf.ts
import crypto from "crypto";

const SECRET = process.env.CSRF_SECRET!;

export function generateCsrfToken(userId: string): string {
  const timestamp = Date.now();
  const data = `${userId}:${timestamp}`;
  const signature = crypto
    .createHmac("sha256", SECRET)
    .update(data)
    .digest("hex");

  return Buffer.from(`${data}:${signature}`).toString("base64");
}

export function verifyCsrfToken(token: string, userId: string): boolean {
  try {
    const decoded = Buffer.from(token, "base64").toString("utf-8");
    const [tokenUserId, timestamp, signature] = decoded.split(":");

    // Check expiry (1 hour)
    if (Date.now() - parseInt(timestamp) > 60 * 60 * 1000) {
      return false;
    }

    // Verify user
    if (tokenUserId !== userId) {
      return false;
    }

    // Verify signature
    const expectedSignature = crypto
      .createHmac("sha256", SECRET)
      .update(`${tokenUserId}:${timestamp}`)
      .digest("hex");

    return signature === expectedSignature;
  } catch {
    return false;
  }
}

// Add to all mutation forms:
const csrfToken = await fetch("/api/csrf").then((r) => r.json());
formData.append("csrfToken", csrfToken);
```

---

## üîµ LOW SEVERITY ISSUES

### 18. **Information Disclosure in Error Messages**

**Files:** Multiple files with console.error statements

**Likelihood:** üîµ **LOW**  
**Impact:** Internal system information exposed

**Fix:**

```typescript
// Use proper logging service instead of console
import * as Sentry from "@sentry/nextjs";

// Replace console.error with:
Sentry.captureException(error, {
  level: "error",
  tags: { component: "bio-page-actions" },
  extra: { slug, userId: session.user.id },
});

// Return generic message to user
return { success: false, message: "operation-failed" };
```

---

### 19. **Lack of Input Length Limits**

**Files:** Multiple forms across the application

**Likelihood:** üîµ **LOW**  
**Impact:** Database bloat, potential DoS

**Fix:**

```typescript
// Add global validation schema
const bioPageUpdateSchema = z
  .object({
    title: z.string().max(100),
    description: z.string().max(500),
    slug: z.string().min(3).max(52),
    // ... other fields
  })
  .strict(); // Reject unknown properties

// Apply in all update actions
const validated = bioPageUpdateSchema.safeParse(data);
if (!validated.success) {
  return { success: false, errors: validated.error.errors };
}
```

---

### 20. **No Audit Logging**

**Files:** All mutation actions

**Likelihood:** üîµ **LOW**  
**Impact:** Difficult to track security incidents

**Fix:**

```typescript
// Create audit log model
// models/AuditLog.ts
const AuditLogSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
  action: { type: String, required: true }, // 'create', 'update', 'delete'
  resource: { type: String, required: true }, // 'bio-page', 'link', etc.
  resourceId: { type: Schema.Types.ObjectId },
  changes: { type: Schema.Types.Mixed },
  ip: String,
  userAgent: String,
  timestamp: { type: Date, default: Date.now },
});

// Use in all critical actions:
await AuditLog.create({
  userId: session.user.id,
  action: "update",
  resource: "bio-page",
  resourceId: bioPage._id,
  changes: { before: oldData, after: newData },
  ip: req.headers.get("x-forwarded-for"),
  userAgent: req.headers.get("user-agent"),
});
```

---

### 21. **Inefficient Database Queries**

**Files:** Multiple locations with missing indexes

**Likelihood:** üîµ **MEDIUM**  
**Impact:** Performance degradation as data grows

**Fix:**

```typescript
// Add indexes to models
// models/url/UrlV3.ts
UrlV3Schema.index({ userId: 1, createdAt: -1 });
UrlV3Schema.index({ urlCode: 1 }, { unique: true });
UrlV3Schema.index({ userId: 1, tags: 1 });

// models/url/Click.ts
ClickSchema.index({ urlCode: 1, timestamp: -1 });
ClickSchema.index({ urlCode: 1, country: 1 });

// models/link-in-bio/BioPage.ts
BioPageSchema.index({ userId: 1 });
BioPageSchema.index({ slug: 1 }, { unique: true });
BioPageSchema.index({ "links.link": 1 });
```

---

### 22. **Lack of Data Retention Policies**

**Files:** Click.ts, LoginActivity.ts

**Likelihood:** üîµ **LOW**  
**Impact:** Database bloat, GDPR non-compliance

**Fix:**

```typescript
// Add TTL indexes for automatic cleanup
ClickSchema.index(
  { timestamp: 1 },
  { expireAfterSeconds: 365 * 24 * 60 * 60 }, // 1 year
);

LoginActivitySchema.index(
  { timestamp: 1 },
  { expireAfterSeconds: 90 * 24 * 60 * 60 }, // 90 days
);

// Create data export functionality for GDPR
export async function exportUserData(userId: string) {
  const [links, bioPages, clicks, qrCodes] = await Promise.all([
    UrlV3.find({ userId }).lean(),
    BioPage.find({ userId }).lean(),
    Click.find({ userId }).lean(),
    QRCodeV2.find({ userId }).lean(),
  ]);

  return {
    links,
    bioPages,
    clicks: clicks.length, // Anonymize click data
    qrCodes,
    exportedAt: new Date().toISOString(),
  };
}
```

---

### 23. **Missing Health Check Endpoint**

**Files:** N/A (missing)

**Likelihood:** üîµ **LOW**  
**Impact:** Difficult to monitor application health

**Fix:**

```typescript
// app/api/health/route.ts
import { NextResponse } from "next/server";
import mongoose from "mongoose";

export async function GET() {
  const checks = {
    database: false,
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
  };

  try {
    // Check DB connection
    if (mongoose.connection.readyState === 1) {
      checks.database = true;
    }

    const status = checks.database ? 200 : 503;
    return NextResponse.json(checks, { status });
  } catch (error) {
    return NextResponse.json(
      { ...checks, error: "Health check failed" },
      { status: 503 },
    );
  }
}
```

---

## üìã PRIORITY RECOMMENDATIONS

### Immediate Actions (Within 24 Hours):

1. ‚úÖ Rotate all exposed credentials
2. ‚úÖ Add .env to .gitignore and remove from git history
3. ‚úÖ Implement Stripe webhook signature verification
4. ‚úÖ Add authentication to all API endpoints
5. ‚úÖ Sanitize all user inputs for XSS

### Short Term (Within 1 Week):

6. ‚úÖ Implement rate limiting
7. ‚úÖ Add CSRF protection
8. ‚úÖ Fix NoSQL injection vulnerabilities
9. ‚úÖ Implement proper error handling
10. ‚úÖ Add file upload security

### Medium Term (Within 1 Month):

11. ‚úÖ Add audit logging
12. ‚úÖ Implement database transactions
13. ‚úÖ Add comprehensive monitoring
14. ‚úÖ Security headers and CORS
15. ‚úÖ Database indexes and optimization

### Long Term (Ongoing):

16. ‚úÖ Regular security audits
17. ‚úÖ Penetration testing
18. ‚úÖ Dependency updates
19. ‚úÖ Security training
20. ‚úÖ Compliance reviews (GDPR, etc.)

---

## üõ†Ô∏è RECOMMENDED TOOLS

```bash
# Install security packages
npm install --save \
  helmet \
  express-rate-limit \
  express-mongo-sanitize \
  xss-clean \
  hpp \
  cors \
  @upstash/ratelimit \
  @upstash/redis \
  isomorphic-dompurify \
  zxcvbn \
  sharp

# Install dev dependencies
npm install --save-dev \
  @types/node \
  eslint-plugin-security \
  npm-audit-resolver
```

---
